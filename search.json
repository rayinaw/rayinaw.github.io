[{"title":"Introduction to Java Deserialization","date":"2022-11-02T19:50:28.000Z","url":"/2022/11/03/JavaDeserializationBasic/","tags":[["Java","/tags/Java/"],["Deserialization","/tags/Deserialization/"]],"categories":[["Java","/categories/Java/"],["Deserialization","/categories/Java/Deserialization/"]],"content":"Bài viết này là về những concept cơ bản của quá trình Serialization và Deserialization và cách mà lỗ hổng Java Deserialization được thực thi. Serialization và Deserialization1. Serialization và deserialization là gì?Hiểu một cách đơn giản hai quá trình này là: Serialization: Object –&gt; string hay bytecode(với Java) Deserialization: string hoặc bytecode –&gt; Object 2. Những quá trình cần sử dụng đến Serialization:Lưu các đối tượng (ở đây xem như dữ liệu) vào bộ nhớ, tệp, cơ sở dữ liệu,…Truyền các đối tượng qua mạng.Chuyển đối tượng qua RMI. 3. Triển khai quá trình Ser và Deser cơ bản:Ở đây mình tạo một package SerialBasic rồi cho các lớp vào trong package đó. File Person.java File SerializationTest.java File DeserializationTest.java Đầu tiên ta chạy file SerializationTest.java, sau khi chạy xong ta thấy ở trong thư mục cha của src có một file ser.txt mới được tạo.Tiếp đến chạy file DeserializationTest.java: Giải thích: SerializationTest.javaBan đầu chúng ta khởi tạo một object new FileOutputStream(“ser.txt”), tiếp đến chúng ta khởi tạo một ObjectOutputStream. Rồi thực hiện oos.writeObject(obj) để viết đối tượng vào file ser.txt DeserializationTest.java Cách mà lỗ hổng Deserialization xảy ra:Ở đây mình dùng Intellij để thực hiện, một IDEA rất tiện lợi mà ai làm việc với Java đều sử dụng.Mình chỉ nói đến một chuỗi cơ bản để các bạn có thể hình dung cách thực hiện và bắt đầu với Deserialization trong Java nhé ^^. 1. HashMap và cách nó gây ra lỗ hổng Deserialization:Gõ Ctrl + N và tìm kiếm lớp HashMap: Lớp HashMap này có implements lớp Serializable vậy nên chúng ta có thể dùng nó để lợi dụng quá trình Ser và Deser. Tiếp theo mở phần Structure và tìm kiến method readObject của lớp HashMap: Trong method readObject ta thấy có phần quan trọng ở đây: Đầu tiên thực hiện gán key và value &#x3D; s.readObject() Sau đó thực hiện hàm putVal(), điểm cần chú ý ở đây là nó đưa key vào method hash(). Ctrl + Chuột trái để đi vào phương thức hash():Trong phương thức hash này, nếu key &#x3D;&#x3D; null sẽ return 0, còn không thì sẽ thực hiện h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) rồi return h.Điểm mà chúng ta cần chú ý ở đây là nó thực hiện key.hashCode() mình sẽ đi sâu một chút cho các bạn dễ hiểu: Trong Java có một lớp là cha của mọi lớp đó là lớp Object, nó có các phương thức như toString(), hashCode(),… key là một object của lớp hashMap mà implements ngầm lớp Object (vì nó cha của mọi lớp mà) vậy nên nó thừa hưởng các phương thức của lớp Object. Nên ở đây chúng ta có thể gọi key.hashCode() Việc gọi hashCode() ở đây có ý nghĩa gì thì chúng ta cùng đi sâu vào chuổi URLDNS nhé! 2. Phân tích chuỗi URLDNS:Chuỗi URLDNS là một chuỗi đơn giản nhất trong các gadget chain (đương nhiên sẽ hơi khó hiểu với người bắt đầu, keep going ^^). Chuỗi này không thực sự gây ra một vấn đề gì nghiêm trọng như là RCE hay là SSRF…, kết quả của chuỗi này là thực hiện một yêu cầu DNS đến địa chỉ mà chúng ta đưa vào. Nó có kết quả phải không nào ^^, vậy nên chuỗi này sẽ giúp các bạn biết được một gadget chain sẽ xảy ra như thế nào. Cố gắng viết code, đọc hiểu để nhanh tiến bộ nhé ٩(^‿^)۶… Chuỗi thực thi của URLDNS như sau: Để tạo một HashMap, đầu tiên chúng ta thực hiện tạo một object hashmap, sau đó chúng ta sẽ thực hiện hàm put() để đưa dữ liệu vào trong object HashMap đó. Ở đây tham số đầu tiên của hàm put() là một object key, và tham số thứ hai là value. Hai biến này tương ứng với key và value mình đã phân tích ở trên phần phân tích về HashMap. Ở đây vì key nhận vào là một object nên ở đây chúng ta sẽ tạo một object URL để thực hiện chain này.Bây giờ, giả sử như chúng ta thực hiện readObject hashmap, nó sẽ đi theo sơ đồ: Và đến đây, phương thức hashCode() được gọi sau khi readObject() sẽ phát huy tác dụng. Chúng ta sẽ đi sâu vào phần này:Tiếp tục chúng ta tìm class URL rồi tìm đến method hashCode(). Ở đây, phương thức hashCode() của lớp Object đã được định nghĩa lại trong lớp URL: Nếu hashCode không bằng -1 thì sẽ thực hiện return hashCode bởi vì nó đã được set rồi. Nếu không thì hashCode sẽ được gán bằng handler.hashCode(this), this ở đây có nghĩa là nó sẽ lấy object của lớp hiện tại đưa vào handler.hashCode rồi thực hiện tiếp.Tiến hành Ctrl+Chuột trái rồi nhấn vào handler để đi đến nơi mà biến hanler được tạo.Ảnh biến handler Biến handler ở đây là một object của lớp URLStreamHandler, object này sẽ gọi đến phương thức hashCode() được định nghĩa trong lớp này. Tiến hành Ctrl+Chuột trái rồi click vào URLStreamHandler, rồi tìm đến phương thức hashCode(). Trong phương thức này chúng ta thấy dòng InetAddress addr = getHostAddress(u); có nghĩa là nó sẽ thực hiện một yêu cầu DNS đến địa chỉ URL để thực hiện getHostAddress. Đến đây ta đạt được mục đích của Chain này đó là request đến địa chỉ URL mà ta cung cấp. Còn lại phần sau và việc nó thực hiện request thế nào thì chúng ta không cần quan tâm, chỉ vậy là đã đủ (Đương nhiên bạn nào thích thì cứ tìm hiểu nhé ^^). 3. POC cho chuỗi URLDNS:Link nhận DNS request:  Chú ý khi thực hiện serialize object của lớp HashMap:Filename: SerializeTest.java Sau khi chạy file này, dù chưa thực hiện deserialize file Ser2.txt mà chúng ta đã nhận được request đến. Nguyên nhân là do khi thực hiện gán giá trị vào object hashmap bằng hashmap.put(), hàm hash trong phương thức này đã được thực hiện và sẽ request đến địa chỉ URL mà ta cung cấp.Sau khi request đến URL, biến hashcode bây giờ đã không còn là -1 nữa, khi đó trong quá trình deserialize request sẽ không được gửi đến. Vậy nên sau khi thực hiện deserialize, chúng ta cần thực hiện set lại giá trị cho hashcode là -1. Tuy nhiên vấn đề ở đây là biến hashcode là private, để gán lại giá trị cho biến private chúng ta cần sử dụng đến Reflection mà mình đã có bài viết về nó. POC hoàn thiện của chuỗi URLDNS:file: SerializeTest.java file: Deser.java Kết quả: Vậy là mình đã giới thiệu xong về cơ bản của quá trình Deserialization và đi qua hết chuỗi URLDNS. Đây chỉ là những kiến thức cơ bản của lỗ hổng Java Deserialization. Để hiểu sâu hơn về lỗ hổng này, mình thực sự khuyên các bạn hãy hiểu tường tận về những keyword sau: “Class Class”, “Class Object”, “Class Runtime”, “Reflection”, các khái niệm về OOP, và còn nhiều thứ khác nữa. Và hãy cố gắng đọc hiểu và tự mình viết POC cho lỗ hổng này, khá khó để bắt đầu nhưng hi vọng các bạn có thể vượt qua. Hành trình nào mà không có gian nan, đau khổ ^^… Chúc các bạn học tốt~ "},{"title":"Java Reflection","date":"2022-11-02T16:23:23.000Z","url":"/2022/11/02/Java-reflection/","tags":[["Java","/tags/Java/"],["Reflection","/tags/Reflection/"],["Programming","/tags/Programming/"]],"categories":[["Java","/categories/Java/"],["Programming","/categories/Java/Programming/"]],"content":"Lớp Java Reflection là một lớp thường xuyên được sử dụng vì sự tiện nghi của nó, nên chúng ta cũng có thể thường xuyên thấy những lớp này khi đi sâu vào những lỗ hổng của Java. Ngoài ra, trong Java Deserialization ta thường dùng lớp này để có thể truy cập vào các thuộc tính Private. Trước khi đọc bài viết này, các bạn nên tìm hiểu lớp Class, Object. Tản mạn thế là đủ rồi, ta cùng đi vào bài viết nào o(￣▽￣)ブ Java Reflection1. Khái niệm:Reflection là một tính năng của java, nó cho phép một chương trình đang chạy trực tiếp lấy ra các thuộc tính, phương thức,… và thao tác với nó. Một điểm đặc biệt của Java reflection là nó cho phép thay đổi các thuộc tính Private của một Object. 2. Các hàm của Java reflection:Ở đây mình chỉ liệt kê ra những hàm thường dùng của Reflection. Lấy ra thuộc tính của một lớp (Field):Trong lớp Class có hai phương thức để lấy ra trường ở trong một lớp là getDeclaredFields() và getDeclaredField(String name). Phương thức getDeclaredFields() sẽ lấy ra tất cả những trường có ở trong class của object đó. Phương thức getDeclaredField(String name) sẽ lấy ra một trường có tên là String mà chúng ta truyền vào. Hai phương thức này tương tự nhau chỉ là phương thức getDeclaredFields() sẽ lấy ra tất cả các field của Class đó rồi cho vào một mảng nên các bạn tự tìm hiểu nhé.. Lấy ra phương thức của một lớp: Method Public Non-public Inherited getMethod &amp; getMethods ✔️ ❌ ✔️ getDeclaredMethod &amp; getDeclaredMethods ✔️ ✔️ ❌ Phương thức getMethod() và getMethods():Hàm getMethod() và getMethods() sẽ có thể lấy những method public và những method được kế thừa từ lớp cha của nó. Lớp getMethod() sẽ trả về một phương thức xác định, còn lớp getMethods() sẽ trả về một mảng các phương thức. Phương thức getDeclaredMethod() và getDeclaredMethods():Hàm getDeclaredMethod() và getDeclaredMethods() sẽ lấy ra những phương thức được định nghĩa ở trong class hiện tại, bao gồm cả Public và Non-public nhưng không thể lấy những class kế thừa như của getMethod(). Tương tự như vậy, lớp getDeclaredMethod() sẽ trả về một phương thức xác định, còn lớp getDeclaredMethods() sẽ trả về một mảng các phương thức. Các phương thức đều tương tự nhau nên mình sẽ chỉ đưa ra một ví dụ: Class.getMethod() nhận tham số đầu là string với tên của method, các tham số sau là lớp của đối số mà method cần lấy ra nhận vào. Như ví dụ trên, lớp work nhận vào 2 tham số là String nên chúng ta sẽ truyền vào String.class,… method lấy ra bây giờ là một object của lớp Method bây giờ nó đại diện cho các method của những object thuộc chung một class có method được lấy ra. Trong lớp Method có một hàm invoke() dùng để gọi cái method đó. Và đương nhiên method bây giờ chưa phải là của object nào mà nó chỉ chung chung, bây giờ hàm invoke() sẽ nhận đối số đầu tiên là object chứa method đó, các giá trị sau là các tham số của method. Lưu ý method chỉ sử dụng nếu các object là chung một class. Phương thức getConstructor() và getConstructors():Phương thức này giúp chúng ta lấy ra một Constructor của một lớp và đưa vào lớp Constructor, từ Constructor được lấy ra, chúng ta có thể tạo một Object bằng hàm newInstance() ở trong lớp Constructor.Phương thức getConstructors() tương tự, chỉ khác là nó sẽ đưa vào mảng. "}]