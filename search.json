[{"title":"Khái niệm cơ bản về HTTP request smuggling với HTTP/1.1","date":"2022-11-30T03:36:10.000Z","url":"/2022/11/30/http-request-smuggling-HTTP-1.1/","tags":[["HRS","/tags/HRS/"]],"categories":[["HTTP Request Smuggling","/categories/HTTP-Request-Smuggling/"]],"content":"Lời nói đầu:Bài viết này là về khái niệm và cách HRS xảy ra đối với HTTP&#x2F;1.1, với HTTP&#x2F;2.0 và thực hành các bạn có thể xem ở bài viết sau. Một vài kiến thức cần nắm:Keep-Alive và Pipelining:Keep-Alive và Pipelining được giới thiệu trong RFC-2616:Keep-Alive cho phép một kết nối TCP giữa Client và Server được tiếp tục gửi và nhận HTTP requests và responses thay vì mở lại kết nối sau mỗi lần Client yêu cầu. Theo như mình thấy thì một số server sẽ set out timeout cho một kết nối keep-alive, sau khi user 1 yêu cầu đến server và server gửi response về, kết nối vẫn được mở và user khác có thể sử dụng kết nối này. Để bật mode Keep-Alive chúng ta cần thêm trường Connection: Keep-Alive vào request. Pipelining cho phép client gửi nhiều yêu cầu HTTP một lúc mà không cần đợi phản hồi của server thông qua một kết nối TCP được mở, server sẽ phản hồi theo thứ tự mà request được gửi đi. Để bật mode Pipeline chúng ta cần thêm trường Connection: Pipelining vào request. Content-Length:Đối với một yêu cầu POST, bắt buộc phải có 1 hoặc hơn trong 3 phương thức Content-Length, Transfer-Encoding, Content-Type và đương nhiên nó phải đúng định dạng. Content-Length và Transfer-Encoding:Content-Length đề cập đến kích thước phần body của một yêu cầu HTTP tính bằng byte. Nếu một tệp văn bản được nén, thì Content-Length của nó sẽ là kích thước được nén. Tiêu đề Content-Length chỉ có ở POST request vì nó có trường nội dung còn GET request thì không. Transfer-Encoding:Transfer-Encoding chỉ ra kiểu truyền tải nào được sử dụng để truyền tải nội dung(phần body). Transfer-Encoding có nhiều kiểu truyền tải, nhưng với lỗi HRS chúng ta chỉ cần chú ý đến phương thức Transfer-Encoding: chunked. Với Transfer-Encoding: chunked Dữ liệu body sẽ được truyền theo từng khối. Bắt đầu bởi một số hex biểu thị số byte của nội dung đầu tiên, tiếp theo sau là data. Tiếp đến là lần lượt những đoạn hex, data như vậy. Để kết thúc nội dung byte cuối cùng sẽ là 0 và theo sau là \\r\\n. Một \\r\\n được gọi là một CRLF, độ dài không bao gồm CRLF. Ví dụ: Ở phương thức Transfer-Encoding chúng ta cần nắm cách đếm byte: Nếu dữ liệu trên 1 dòng thì không cần đếm \\r\\n sau nó. Nếu dữ liệu nhiều dòng như dòng E\\r\\n (bytes to send) ở trên thì chúng ta cần đếm hết kể cả \\r \\n (lưu ý \\r hay \\n chỉ tính là 1 byte), ở dòng cuối cùng của khối data này có \\r\\n chúng ta sẽ không đếm nó vào. Sau đó chuyển độ dài thành số hex tương ứng. Reverse proxy:Reverse Proxy là một loại proxy server, nó đóng vai trò như một server bình thường. Nó tiếp nhận yêu cầu từ user, rồi chuyển tiếp đến các máy chủ khác xử lý yêu cầu đó rồi trả về cho người dùng. Người dùng ở đây chỉ giao tiếp với reverse proxy server mà không biết về sự tồn tại của máy chủ khác.Cấu trúc của một request từ user đến một máy chủ có tồn tại reverse proxy như sau:user —request—&gt; reverse proxy —request—&gt; back-end serveruser &lt;–response— reverse proxy &lt;–response— back-end server Khái niệm web cache:Web cache sinh ra để nâng cao trải nghiệm người dùng. Khi người dùng yêu cầu như những dữ liệu như HTML, CSS, Javascript, image,…, server có thể sẽ lưu vào web cache để không phải thực hiện lại những truy vấn để lấy những dữ liệu đó, giúp cho việc lấy dữ liệu nhanh hơn, đỡ tốn tài nguyên hơn cho người dùng. Có một số loại web cache như sau:Web cache ở phía browser: Sau khi người dùng thực hiện request lần đầu tiên đến server, nếu server hỗ trợ cache ở browser người dùng, dữ liệu sẽ được lưu vào cache ở browser của người dùng (nên xóa lịch sử web hay có mục cache). Khi người dùng request những lần tiếp theo tương tự như yêu cầu đầu tiên, browser chỉ cần lấy từ cache của browser để render ra cho người dùng.Web cache phía Proxy Server: Nó thường là CDN caching. Nó hoạt động tương tự như browser caching tuy nhiên nơi lưu trữ cache ở đây là CDN server trên toàn thế giới. Ở đây nhiều user có thể dùng chung cache từ server gửi đến máy chủ CDN. Cách hoạt động các bạn có thể tham khảo thêm ở .Web cache phía Reverse Proxy server: Cũng hoạt động tương tự như hai kiểu trên, tuy nhiên cache được lưu trữ ở phía Reverse Proxy.Các bạn có thể tham khảo thêm về web cache ở Yêu cầu của lỗi HRS:Để một lỗi HRS xảy ra, trang web cần đáp ứng những yêu cầu sau: Trang web bao gồm hai máy chủ front-end (reverse proxy) và máy chủ back-end. Máy chủ phải hỗ trợ Keep-Alive hoặc Pipelining để yêu cầu có thể gắn với yêu cầu của nạn nhân (Nếu bạn không hiểu thì cứ bỏ qua, đọc phần sau sẽ hiểu) Máy chủ front-end và back-end phân tích các trường Transfer-Encoding, Content-Length không nghiêm ngặt khiến cho quá trình phân tích mắc sai lầm phát sinh lỗi. HTTP request smuggling ở HTTP&#x2F;1.1CL(Content-Length) không bằng 0:GET mang nội dung thì khá lạ, nhưng mà này thực sự xảy ra. Khá khó hiểu với mình. Vấn đề: Máy chủ proxy cho phép yêu cầu GET mang nội dung, nhưng máy chủ phía sau không cho phép mang nội dung request, máy chủ phía sau sẽ trực tiếp bỏ trường Content-Length và không xử lý nó. Từ đây nó sẽ phát sinh ra lỗi HRS.Ví dụ:Một request như sau: Máy chủ Proxy nhận được yêu cầu, như mình đã nói, vì một lý do nào đó mà request này được chấp nhận ở máy chủ Proxy mình không biết :). Nó sẽ chuyển đến máy chủ phía sau, tại đây nó không chấp nhận trường Content-Length nên nó sẽ xem như là yêu cầu riêng biệt, và nếu máy chủ có sử dụng pipelining, nó sẽ xem như là hai yêu cầu riêng biệt.Yêu cầu thứ nhất: Yêu cầu thứ hai: CL-CL:Kĩ thuật tấn công CL-CL là một yêu cầu HTTP chứa 2 trường Content-Length. Theo , nếu máy chủ nhận được hai yêu cầu Content-Length và giá trị của 2 yêu cầu đó khác nhau thì nó sẽ trả về lỗi 400. Tuy nhiên đôi lúc sẽ có những máy chủ không tuân thủ nghiêm ngặt thông số này và dẫn đến HRS. Giả sử một kịch bản tấn công sẽ là cả máy chủ proxy và máy chủ gốc đề không trả về lỗi 400, và máy chủ proxy sử dụng trường Content-Length đầu tiên và máy chủ gốc sử dụng trường Content-Length thứ hai. Ví dụ một request như sau: Phân tích: Máy chủ proxy nhận Content-Length: 8\\r\\n, dòng thứ 5 trống là một dòng thông thường của yêu cầu POST nên không tính vào phần nội dung, 12345 + \\r + \\n + a = 8 bytes thõa mãn với trường Content-Lengthnên nó chuyển tiếp yêu cầu đến máy chủ back-end. Máy chủ Back-End nhận trường Content-Length: 7\\r\\n, sau khi đọc 7 kí tự đầu tiên là hết dòng thứ 6, máy chủ Back-End cho rằng quá trình đọc đã hoàn thành sau đó gửi response về cho client. Lúc này trong bộ đệm còn một kí tự a, máy chủ back-end sẽ xem như đây là một phần của yêu cầu (request) tiếp theo. Bây giờ giả sử như có một người dùng khác gửi một yêu cầu đến máy chủ: Dựa trên việc sử dụng lại kết nối TCP giữa máy chủ proxy và máy chủ back-end, a sẽ được kết hợp với yêu cầu này để tạo thành một yêu cầu mới: Lúc này tại máy khách sẽ nhận được một lỗi aGET request method not found, cho chúng ta biết được rằng HRS đã xảy ra. CL-TETrong trường hợp này, máy chủ Front-End sử dụng Content-Length và máy chủ Back-End sử dụng Transfer-Encoding. Giả sử một yêu cầu như sau: Máy chủ Front-End nhận trường Content-Length: 6\\r\\n, dòng thứ 6 không tính vào Content-Length, dòng 7-9 có 0 + \\r\\n + \\r\\n + a = 6 bytes thõa mãn, nên yêu cầu được chuyển đến máy chủ back-end.Máy chủ Back-End nhận Transfer-Encoding: chunked\\r\\n, khi nhận được cờ 0\\r\\n và dòng sau là \\r\\n máy chủ sẽ xem như là phần body đã kết thúc và lúc này kí tự a vẫn còn nằm trong bộ đệm. Tương tự như CL-CL nếu bây giờ có một yêu cầu gửi đến: Nó sẽ gộp kí tự a với request này thành: Và client sẽ nhận lỗi Unrecognized method aPOST có nghĩa là HRS đã xảy ra. TE-CLMáy chủ Front-End sử dụng tiêu đề Transfer-Encoding, máy chủ Back-End sử dụng tiêu đề Content-Length.Xét request như sau: Máy chủ front-end nhận Transfer-Encoding: chunked\\r\\n, khi đọc đến 0\\r\\n và \\r\\nở cuối, không có vấn đề gì xảy ra nên máy chủ front-end request đến máy chủ back-end.Máy chủ back-end nhận trường Content-Length: 4\\r\\n, vì độ dày chỉ 4 bytes tương đương 12 + \\r + \\r là đến hết dòng thứ 6, máy chủ back-end sẽ xem là đã kết thúc request và phần còn lại từ dòng 7 trở đi không được xử lý và máy chủ back-end sẽ coi đây là phần bắt đầu của yêu cầu tiếp theo. Tại thời điểm này nếu có một yêu cầu khác nó sẽ báo lỗi Unrecognized method aPOST, có nghĩa là HRS đã thành công. TE-TECả máy chủ front-end và máy chủ back-end đều sử dụng Transfer-Encoding nhưng bằng một cách nào đó chúng ta có thể gây nhầm lẫn cho máy chủ để một trong hai máy chủ front-end và back-end không xử lý Transfer-Encoding như bình thường, khi đó chúng ta có thể khai thác lỗ hỏng CL-TE hoặc TE-CL tùy theo cách xử lý của reverse proxy và back-end. Một số cách để gây rối cho máy chủ như sau: Giả sử chúng ta có một request như sau: Máy chủ Proxy nhận Transfer-Encoding: chunked\\r\\n, thấy yêu cầu hợp lệ nó gửi đến máy chủ back-end.Máy chủ back-end: Lúc này do tồn tại hai trường Transfer-Encoding: chunked\\r\\n và Transfer-encoding: cow\\r\\n nên khiến máy chủ bị rối, nó không biết nhận cái nào nên có thể bây giờ nó sẽ nhận Content-length: 4\\r\\n. 5c\\r\\n = 4bytes nên phần sau được xem như là một yêu cầu khác, và do máy chủ tồn tại pipelining nên nó được coi như là một yêu cầu khác biệt. Lúc này một lỗi Unrecognized method aPOST sẽ được trả về. Web cache poisoning thông qua HRS:Tham khảo:    "},{"title":"Tính năng mới của Mysql 8","date":"2022-11-27T15:13:20.000Z","url":"/2022/11/27/sqli-mysql8/","tags":[["Mysql","/tags/Mysql/"],["SQLi","/tags/SQLi/"]],"categories":[["Mysql","/categories/Mysql/"],["SQLi","/categories/Mysql/SQLi/"]],"content":"Tính năng mới của mysql8Câu lệnh TABLE Chức năng: Trả về các hàng và cột của bảng được chỉ định Trông thì tương tự như câu lệnh select. Kể cả kết hợp order. Tuy nhiên điểm khác ở đây là câu lệnh table sẽ lấy ra toàn bộ bảng, vậy nên where clause sẽ không có tác dụng, nó sẽ đưa ra lỗi. Câu lệnh VALUES Câu lệnh nhìn khá phức tạp, đơn giản nó chỉ đưa ra các row mà chúng ta định nghĩa. Ví dụ cho dễ hiểu: Câu lệnh này có thể kết hợp với union như sau: Sử dụng câu lệnh table để dump database: Để dump ra tên SCHEMA_NAME bằng hàm table ta sẽ sử dụng Boolean-based SQL Injection. Để dễ hình dung chúng ta cùng đi vào ví dụ: Lưu ý là nếu chúng ta cần tìm cột sau thì phải biết giá trị cột trước mới so sánh được, các cột sau không quan trọng. Ở đây giá trị của cột đầu tiên sẽ là def, cột thứ 2 là tên database, các cột sau là không quan trọng đối với chúng ta. Chúng ta cùng đi vào phần boolean của payload: Câu lệnh này ở đây phần sẽ tương đương với việc so sánh chuỗi thứ 2 thuộc (‘def’,’m’,3,4,5,6) với chuỗi thứ 2 từ information_schema.schemata. Và với chỉ 1 kí tự nó sẽ so sánh kí tự đó với kí tự đầu của chuỗi, ở đây là l và mysql sẽ tương đương với so sánh l với m. Và vì l&lt;&#x3D;m nên trả về true, m&lt;&#x3D;m nên cũng trả về true, và với n&gt;m nên trả về false. Vậy với việc select với boolean mà ra giá trị có nghĩa là kí tự đó vẫn đang &lt;&#x3D; kí tự cần tìm. Rồi đến khi clause là false tương đương với kí tự đó lớn hơn kí tự cần tìm, thì ta sẽ xác định kí tự trước đó là kí tự chúng ta cần tìm. Tương tự như thế và ta sẽ có được tên database đầu tiên. Tiếp tục chúng ta sẽ thay đổi limit clause để lấy từng database ra. Test trực tiếp bằng sql-labsXây dựng môi trường:Đầu tiên các bạn cần cài đặt docker, khá là dễ thôi nên các bạn tự mình cài lấy nhé. Cài đặt sqli-labs: Tiếp theo cài đặt Mysql 8: Trong terminal gõ docker ps để lấy id của container.Tiếp theo thay đổi cấu hình của sqli-labs: Tiếp theo sử dụng vim để thay đổi nội dung của file db-creds.inc. Hơi khó sử dụng, các bạn tự đọc nhé ^^. Cấu hình mysql: Thế là đã xong. Bây giờ gõ localhost trên trình duyệt là sẽ thấy trang web. Dump database: Vế phía sau and trả về true thì trên màn hình sẽ có Your Login name và Your Password, còn trả về false thì sẽ không xuất hiện gì cả. Từ đây chúng ta có thể sử dụng boolean sqli kết hợp câu lệnh table để dump ra database. Chúng ta cần lưu ý về kí tự cuối cùng, (&#39;def&#39;,&#39;mysql&#39;,3,4,5,6) sẽ không bằng với (table information_schema.schemata limit 0,1) nên kí tự cuối sẽ dừng ở chữ k, chuổi bây giờ sẽ là mysqk và với các kí tự nhiễu sau nó sẽ là không bằng và sẽ tiếp tục chạy. Ví dụ ở script dưới sẽ dừng khi i chạy hết 1 đến 20. Khi đó chúng ta có thể cho chạy vậy hoặc lọc cái đó ra vì nó không ảnh hưởng đến kết quả(các bạn test thì sẽ thấy ^^). Ví dụ: Script dump database: Dump table:Tìm số cột của bảng information_schema.tables: Vậy bảng này có 21 cột. Payload tiếp theo sẽ có dạng: Ở đây, ô đầu tiên là def, ô thứ 2 là database cần tìm table, ô thứ 3 là table. Các ô sau là không quan trọng. Tuy nhiên chúng ta cần phải limit table đúng với từng database. Không có một cách tìm cụ thể, nên việc test khoảng tìm là cần thiết. Đây là source cho việc dump table_name của mysql Hmm, ở trên k hay cho lắm cái này thuận lợi cho việc dò tìm hơn: Với payload của mình nếu không đúng index so với database thì nó sẽ có table_name là “__________________&#96;” hoặc là string trống. Để tìm đúng thì chúng ta sẽ dò đến khi có tên hợp lý. Script dump table_name: Dump column_name:Bảng này có 22 cột. Tương tự như information_schema.tables bảng này cần thêm 2 giá trị xác định là database và table, và dò khoảng đúng với database và table của column. Việc dò này các bạn lưu ý tự dò nhé, bởi vì với mỗi phiên bản sẽ có thêm những table và column nên nó chỉ gần sát với khoảng của mình thôi. Script dump column_name: Dump bảng đã được xác định:Mình không hiểu tại sao bây giờ giả sử giá trị cần tìm là dump, thì mình xét với dump thì nó vẫn trả về true. Nhưng mà cũng không quan trọng lắm, làm theo cái mình test thôi à ^^. huhu kĩ năng lập trình kém nên không biết viết như nào cho chuẩn nhất (lười quá), script của mình ở dưới bị dính thằng ‘0’ cách mình bypass chưa tối ưu, nếu giá trị có số 0 thì mình sai nhưng mà lười viết quá.Dump id: Dump username Dump password: HANDLER StatementSystax: Alias tên bảng: "},{"title":"Introduction to Java Deserialization","date":"2022-11-02T19:50:28.000Z","url":"/2022/11/03/JavaDeserializationBasic/","tags":[["Java","/tags/Java/"],["Deserialization","/tags/Deserialization/"]],"categories":[["Java","/categories/Java/"],["Deserialization","/categories/Java/Deserialization/"]],"content":"Bài viết này là về những concept cơ bản của quá trình Serialization và Deserialization và cách mà lỗ hổng Java Deserialization được thực thi. Serialization và Deserialization1. Serialization và deserialization là gì?Hiểu một cách đơn giản hai quá trình này là: Serialization: Object –&gt; string hay bytecode(với Java) Deserialization: string hoặc bytecode –&gt; Object 2. Những quá trình cần sử dụng đến Serialization:Lưu các đối tượng (ở đây xem như dữ liệu) vào bộ nhớ, tệp, cơ sở dữ liệu,…Truyền các đối tượng qua mạng.Chuyển đối tượng qua RMI. 3. Triển khai quá trình Ser và Deser cơ bản:Ở đây mình tạo một package SerialBasic rồi cho các lớp vào trong package đó. File Person.java File SerializationTest.java File DeserializationTest.java Đầu tiên ta chạy file SerializationTest.java, sau khi chạy xong ta thấy ở trong thư mục cha của src có một file ser.txt mới được tạo.Tiếp đến chạy file DeserializationTest.java: Giải thích: SerializationTest.javaBan đầu chúng ta khởi tạo một object new FileOutputStream(“ser.txt”), tiếp đến chúng ta khởi tạo một ObjectOutputStream. Rồi thực hiện oos.writeObject(obj) để viết đối tượng vào file ser.txt DeserializationTest.java Cách mà lỗ hổng Deserialization xảy ra:Ở đây mình dùng Intellij để thực hiện, một IDEA rất tiện lợi mà ai làm việc với Java đều sử dụng.Mình chỉ nói đến một chuỗi cơ bản để các bạn có thể hình dung cách thực hiện và bắt đầu với Deserialization trong Java nhé ^^. 1. HashMap và cách nó gây ra lỗ hổng Deserialization:Gõ Ctrl + N và tìm kiếm lớp HashMap: Lớp HashMap này có implements lớp Serializable vậy nên chúng ta có thể dùng nó để lợi dụng quá trình Ser và Deser. Tiếp theo mở phần Structure và tìm kiến method readObject của lớp HashMap: Trong method readObject ta thấy có phần quan trọng ở đây: Đầu tiên thực hiện gán key và value &#x3D; s.readObject() Sau đó thực hiện hàm putVal(), điểm cần chú ý ở đây là nó đưa key vào method hash(). Ctrl + Chuột trái để đi vào phương thức hash():Trong phương thức hash này, nếu key &#x3D;&#x3D; null sẽ return 0, còn không thì sẽ thực hiện h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) rồi return h.Điểm mà chúng ta cần chú ý ở đây là nó thực hiện key.hashCode() mình sẽ đi sâu một chút cho các bạn dễ hiểu: Trong Java có một lớp là cha của mọi lớp đó là lớp Object, nó có các phương thức như toString(), hashCode(),… key là một object của lớp hashMap mà implements ngầm lớp Object (vì nó cha của mọi lớp mà) vậy nên nó thừa hưởng các phương thức của lớp Object. Nên ở đây chúng ta có thể gọi key.hashCode() Việc gọi hashCode() ở đây có ý nghĩa gì thì chúng ta cùng đi sâu vào chuổi URLDNS nhé! 2. Phân tích chuỗi URLDNS:Chuỗi URLDNS là một chuỗi đơn giản nhất trong các gadget chain (đương nhiên sẽ hơi khó hiểu với người bắt đầu, keep going ^^). Chuỗi này không thực sự gây ra một vấn đề gì nghiêm trọng như là RCE hay là SSRF…, kết quả của chuỗi này là thực hiện một yêu cầu DNS đến địa chỉ mà chúng ta đưa vào. Nó có kết quả phải không nào ^^, vậy nên chuỗi này sẽ giúp các bạn biết được một gadget chain sẽ xảy ra như thế nào. Cố gắng viết code, đọc hiểu để nhanh tiến bộ nhé ٩(^‿^)۶… Chuỗi thực thi của URLDNS như sau: Để tạo một HashMap, đầu tiên chúng ta thực hiện tạo một object hashmap, sau đó chúng ta sẽ thực hiện hàm put() để đưa dữ liệu vào trong object HashMap đó. Ở đây tham số đầu tiên của hàm put() là một object key, và tham số thứ hai là value. Hai biến này tương ứng với key và value mình đã phân tích ở trên phần phân tích về HashMap. Ở đây vì key nhận vào là một object nên ở đây chúng ta sẽ tạo một object URL để thực hiện chain này.Bây giờ, giả sử như chúng ta thực hiện readObject hashmap, nó sẽ đi theo sơ đồ: Và đến đây, phương thức hashCode() được gọi sau khi readObject() sẽ phát huy tác dụng. Chúng ta sẽ đi sâu vào phần này:Tiếp tục chúng ta tìm class URL rồi tìm đến method hashCode(). Ở đây, phương thức hashCode() của lớp Object đã được định nghĩa lại trong lớp URL: Nếu hashCode không bằng -1 thì sẽ thực hiện return hashCode bởi vì nó đã được set rồi. Nếu không thì hashCode sẽ được gán bằng handler.hashCode(this), this ở đây có nghĩa là nó sẽ lấy object của lớp hiện tại đưa vào handler.hashCode rồi thực hiện tiếp.Tiến hành Ctrl+Chuột trái rồi nhấn vào handler để đi đến nơi mà biến hanler được tạo.Ảnh biến handler Biến handler ở đây là một object của lớp URLStreamHandler, object này sẽ gọi đến phương thức hashCode() được định nghĩa trong lớp này. Tiến hành Ctrl+Chuột trái rồi click vào URLStreamHandler, rồi tìm đến phương thức hashCode(). Trong phương thức này chúng ta thấy dòng InetAddress addr = getHostAddress(u); có nghĩa là nó sẽ thực hiện một yêu cầu DNS đến địa chỉ URL để thực hiện getHostAddress. Đến đây ta đạt được mục đích của Chain này đó là request đến địa chỉ URL mà ta cung cấp. Còn lại phần sau và việc nó thực hiện request thế nào thì chúng ta không cần quan tâm, chỉ vậy là đã đủ (Đương nhiên bạn nào thích thì cứ tìm hiểu nhé ^^). 3. POC cho chuỗi URLDNS:Link nhận DNS request:  Chú ý khi thực hiện serialize object của lớp HashMap:Filename: SerializeTest.java Sau khi chạy file này, dù chưa thực hiện deserialize file Ser2.txt mà chúng ta đã nhận được request đến. Nguyên nhân là do khi thực hiện gán giá trị vào object hashmap bằng hashmap.put(), hàm hash trong phương thức này đã được thực hiện và sẽ request đến địa chỉ URL mà ta cung cấp.Sau khi request đến URL, biến hashcode bây giờ đã không còn là -1 nữa, khi đó trong quá trình deserialize request sẽ không được gửi đến. Vậy nên sau khi thực hiện deserialize, chúng ta cần thực hiện set lại giá trị cho hashcode là -1. Tuy nhiên vấn đề ở đây là biến hashcode là private, để gán lại giá trị cho biến private chúng ta cần sử dụng đến Reflection mà mình đã có bài viết về nó. POC hoàn thiện của chuỗi URLDNS:file: SerializeTest.java file: Deser.java Kết quả: Vậy là mình đã giới thiệu xong về cơ bản của quá trình Deserialization và đi qua hết chuỗi URLDNS. Đây chỉ là những kiến thức cơ bản của lỗ hổng Java Deserialization. Để hiểu sâu hơn về lỗ hổng này, mình thực sự khuyên các bạn hãy hiểu tường tận về những keyword sau: “Class Class”, “Class Object”, “Class Runtime”, “Reflection”, các khái niệm về OOP, và còn nhiều thứ khác nữa. Và hãy cố gắng đọc hiểu và tự mình viết POC cho lỗ hổng này, khá khó để bắt đầu nhưng hi vọng các bạn có thể vượt qua. Hành trình nào mà không có gian nan, đau khổ ^^… Chúc các bạn học tốt~ "},{"title":"Java Reflection","date":"2022-11-02T16:23:23.000Z","url":"/2022/11/02/Java-reflection/","tags":[["Java","/tags/Java/"],["Reflection","/tags/Reflection/"],["Programming","/tags/Programming/"]],"categories":[["Java","/categories/Java/"],["Programming","/categories/Java/Programming/"]],"content":"Lớp Java Reflection là một lớp thường xuyên được sử dụng vì sự tiện nghi của nó, nên chúng ta cũng có thể thường xuyên thấy những lớp này khi đi sâu vào những lỗ hổng của Java. Ngoài ra, trong Java Deserialization ta thường dùng lớp này để có thể truy cập vào các thuộc tính Private. Trước khi đọc bài viết này, các bạn nên tìm hiểu lớp Class, Object. Tản mạn thế là đủ rồi, ta cùng đi vào bài viết nào o(￣▽￣)ブ Java Reflection1. Khái niệm:Reflection là một tính năng của java, nó cho phép một chương trình đang chạy trực tiếp lấy ra các thuộc tính, phương thức,… và thao tác với nó. Một điểm đặc biệt của Java reflection là nó cho phép thay đổi các thuộc tính Private của một Object. 2. Các hàm của Java reflection:Ở đây mình chỉ liệt kê ra những hàm thường dùng của Reflection. Lấy ra thuộc tính của một lớp (Field):Trong lớp Class có hai phương thức để lấy ra trường ở trong một lớp là getDeclaredFields() và getDeclaredField(String name). Phương thức getDeclaredFields() sẽ lấy ra tất cả những trường có ở trong class của object đó. Phương thức getDeclaredField(String name) sẽ lấy ra một trường có tên là String mà chúng ta truyền vào. Hai phương thức này tương tự nhau chỉ là phương thức getDeclaredFields() sẽ lấy ra tất cả các field của Class đó rồi cho vào một mảng nên các bạn tự tìm hiểu nhé.. Lấy ra phương thức của một lớp: Method Public Non-public Inherited getMethod &amp; getMethods ✔️ ❌ ✔️ getDeclaredMethod &amp; getDeclaredMethods ✔️ ✔️ ❌ Phương thức getMethod() và getMethods():Hàm getMethod() và getMethods() sẽ có thể lấy những method public và những method được kế thừa từ lớp cha của nó. Lớp getMethod() sẽ trả về một phương thức xác định, còn lớp getMethods() sẽ trả về một mảng các phương thức. Phương thức getDeclaredMethod() và getDeclaredMethods():Hàm getDeclaredMethod() và getDeclaredMethods() sẽ lấy ra những phương thức được định nghĩa ở trong class hiện tại, bao gồm cả Public và Non-public nhưng không thể lấy những class kế thừa như của getMethod(). Tương tự như vậy, lớp getDeclaredMethod() sẽ trả về một phương thức xác định, còn lớp getDeclaredMethods() sẽ trả về một mảng các phương thức. Các phương thức đều tương tự nhau nên mình sẽ chỉ đưa ra một ví dụ: Class.getMethod() nhận tham số đầu là string với tên của method, các tham số sau là lớp của đối số mà method cần lấy ra nhận vào. Như ví dụ trên, lớp work nhận vào 2 tham số là String nên chúng ta sẽ truyền vào String.class,… method lấy ra bây giờ là một object của lớp Method bây giờ nó đại diện cho các method của những object thuộc chung một class có method được lấy ra. Trong lớp Method có một hàm invoke() dùng để gọi cái method đó. Và đương nhiên method bây giờ chưa phải là của object nào mà nó chỉ chung chung, bây giờ hàm invoke() sẽ nhận đối số đầu tiên là object chứa method đó, các giá trị sau là các tham số của method. Lưu ý method chỉ sử dụng nếu các object là chung một class. Phương thức getConstructor() và getConstructors():Phương thức này giúp chúng ta lấy ra một Constructor của một lớp và đưa vào lớp Constructor, từ Constructor được lấy ra, chúng ta có thể tạo một Object bằng hàm newInstance() ở trong lớp Constructor.Phương thức getConstructors() tương tự, chỉ khác là nó sẽ đưa vào mảng. "}]